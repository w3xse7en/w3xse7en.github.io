<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>w3xse7en</title>
    <link>https://w3xse7en.github.io/</link>
      <atom:link href="https://w3xse7en.github.io/index.xml" rel="self" type="application/rss+xml" />
    <description>w3xse7en</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language>
    <image>
      <url>https://w3xse7en.github.io/images/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_2.png</url>
      <title>w3xse7en</title>
      <link>https://w3xse7en.github.io/</link>
    </image>
    
    <item>
      <title>Go</title>
      <link>https://w3xse7en.github.io/docs/lang/go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://w3xse7en.github.io/docs/lang/go/</guid>
      <description>&lt;h2 id=&#34;select&#34;&gt;select&lt;/h2&gt;
&lt;p&gt;go select思想来源于网络IO模型中的select，本质上也是IO多路复用，只不过这里的IO是基于channel而不是基于网络，同时go select也有一些自己不同的特性。&lt;/p&gt;
&lt;h3 id=&#34;特性&#34;&gt;特性:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;每个case都必须是一个通信&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有channel表达式都会被求值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有被发送的表达式都会被求值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果任意某个通信可以进行，它就执行；其他被忽略。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果有多个case都可以运行，select会随机公平地选出一个执行。其他不会执行。否则执行default子句(如果有)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;冷知识：select 使用 c语言 的AsyncCall2函数 该函数执行时间为 200ms&lt;/p&gt;
&lt;p&gt;问题：分别指定耗时50ms，200ms，3000ms，select打印最先完成的异步调用耗时，预想：50ms 先 200ms 后，结果：50ms 与 200ms 随机出现&lt;/p&gt;
&lt;h3 id=&#34;用途&#34;&gt;用途&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;结合特性5,6，可以通过带 default 语句的 select 实现非阻塞读写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结合特性2，每次 select 都会对所有通信表达式求值，因此可通过 time.After简洁实现定时器功能，并且定时任务可通过 done channel 停止&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结合特性4，如果多个case满足读写条件，select会随机选择一个语句执行&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;
&lt;h2 id=&#34;context&#34;&gt;context&lt;/h2&gt;
&lt;p&gt;context.Context 是用来设置截止日期、同步信号，传递请求相关值的结构体。&lt;/p&gt;
&lt;p&gt;在 Goroutine 构成的树形结构中对信号进行同步以减少计算资源的浪费是 context.Context 的最大作用&lt;/p&gt;
&lt;p&gt;每一个 context.Context 都会从最顶层的 Goroutine 一层一层传递到最下层。context.Context 可以在上层 Goroutine 执行出现错误时，将信号及时同步给下层&lt;/p&gt;
&lt;p&gt;当最上层的 Goroutine 因为某些原因执行失败时，下层的 Goroutine 由于没有接收到这个信号所以会继续工作；但是当我们正确地使用 context.Context 时，就可以在下层及时停掉无用的工作以减少额外资源的消耗&lt;/p&gt;
&lt;h1 id=&#34;defer&#34;&gt;defer&lt;/h1&gt;
&lt;p&gt;defer 是否会在panic后执行&lt;/p&gt;
&lt;h1 id=&#34;interface&#34;&gt;interface&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;writing generic algorithm&lt;/li&gt;
&lt;li&gt;hiding implementation detail&lt;/li&gt;
&lt;li&gt;providing interception points&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;interface拥有两个指针
一个指向类型 一个指向具体值&lt;/p&gt;
&lt;h1 id=&#34;slice&#34;&gt;slice&lt;/h1&gt;
&lt;p&gt;分配在连续的内存地址上&lt;/p&gt;
&lt;p&gt;元素类型一致，元素存储宽度一致&lt;/p&gt;
&lt;p&gt;空间大小固定，不能修改&lt;/p&gt;
&lt;p&gt;可以通过索引计算出元素对应存储的位置（只需要知道数组内存的起始位置和数据元素宽度即可）&lt;/p&gt;
&lt;p&gt;会出现数据溢出的问题（下标越界）&lt;/p&gt;
&lt;h2 id=&#34;slice扩容&#34;&gt;slice扩容&lt;/h2&gt;
&lt;p&gt;如果新的slice大小是当前大小2倍以上，则大小增长为新大小&lt;/p&gt;
&lt;p&gt;如果当前slice cap 小于1024，按每次2倍增长，否则每次按当前大小1/4增长。直到增长的大小超过或等于新大小&lt;/p&gt;
&lt;p&gt;append的实现是在内存中将slice的array值赋值到新申请的array上&lt;/p&gt;
&lt;p&gt;性能&lt;/p&gt;
&lt;p&gt;通过上面我们知道slice的扩容涉及到内存的拷贝，这样带来的好处是数据存储在连续内存上，比随机访问快很多，最直接的性能提升就是缓存命中率会高很多,这也就是为什么slice不采用动态链表实现的原因吧&lt;/p&gt;
&lt;p&gt;我们知道拷贝内存数据是有开销的， 而其中最大的开销不在 memmove&lt;/p&gt;
&lt;p&gt;数据上，而是在开辟一块新内存malloc及之后的GC压力&lt;/p&gt;
&lt;p&gt;拷贝连续内存是很快的，随着cap变大，拷贝总成本还是 O(N) ,只是常数大了&lt;/p&gt;
&lt;p&gt;假如不想发生拷贝，那你就没有连续内存。此时随机访问开销会是：链表 O(N)&lt;/p&gt;
&lt;p&gt;当你能大致知道所需的最大空间（在大部分时候都是的）时，在make的时候预留相应的 cap 就好
如果需要的空间很大，而且每次都不确定，那就要在浪费内存和耗 CPU 在 malloc + gc 上做权衡
链表的查找操作是从第一个元素开始，所以相对数组要耗时间的多，因为采用这样的结构对读的性能有很大的提高&lt;/p&gt;
&lt;h2 id=&#34;mysql&#34;&gt;mysql&lt;/h2&gt;
&lt;h3 id=&#34;性能调优&#34;&gt;性能调优&lt;/h3&gt;
&lt;h4 id=&#34;sql优化&#34;&gt;SQL优化&lt;/h4&gt;
&lt;p&gt;小表驱动大表
limit限定
索引添加
适当添加冗余字段，减少表关联。&lt;/p&gt;
&lt;h4 id=&#34;系统优化&#34;&gt;系统优化&lt;/h4&gt;
&lt;p&gt;max_connections 最大连接数&lt;/p&gt;
&lt;p&gt;innodb_buffer_pool_size 数据缓冲区buffer pool大小&lt;/p&gt;
&lt;p&gt;sort_buffer_size 排序缓冲区内存大小&lt;/p&gt;
&lt;p&gt;join_buffer_size 使用连接缓冲区大小&lt;/p&gt;
&lt;p&gt;read_buffer_size 全表扫描时分配的缓冲区大小&lt;/p&gt;
&lt;h1 id=&#34;缓存&#34;&gt;缓存&lt;/h1&gt;
&lt;p&gt;主动式缓存
用户更新数据 同时更新缓存&lt;/p&gt;
&lt;p&gt;被动式缓存
用户更新数据 删除缓存，被读取时载入缓存&lt;/p&gt;
&lt;h1 id=&#34;maps&#34;&gt;Maps&lt;/h1&gt;
&lt;p&gt;线程不安全&lt;/p&gt;
&lt;p&gt;底层使用的hash结构&lt;/p&gt;
&lt;p&gt;hash算法使用aes hash hash值分为 高位hash和低位hash&lt;/p&gt;
&lt;p&gt;高位哈希值：是用来确定当前的bucket（桶）有没有所存储的数据的 bmap a bucket for a Go map&lt;/p&gt;
&lt;p&gt;低位哈希值：是用来确定，当前的数据存在了哪个bucket（桶）hmap a header for a go map&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://wudaijun.com/2017/10/go-select/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;go select机制与常见的坑&lt;/a&gt;&lt;/p&gt;
&lt;br/&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Goroutine</title>
      <link>https://w3xse7en.github.io/docs/lang/goroutine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://w3xse7en.github.io/docs/lang/goroutine/</guid>
      <description>&lt;h1 id=&#34;goroutine&#34;&gt;goroutine&lt;/h1&gt;
&lt;p&gt;leak 协程泄露
Goroutine为什么没有ID号&lt;/p&gt;
&lt;h2 id=&#34;goroutine调度&#34;&gt;Goroutine调度&lt;/h2&gt;
&lt;p&gt;G P M
抢占式调度&lt;/p&gt;
&lt;p&gt;动态栈&lt;/p&gt;
&lt;h1 id=&#34;协程线程进程的区别&#34;&gt;协程，线程，进程的区别&lt;/h1&gt;
&lt;h1 id=&#34;进程&#34;&gt;进程&lt;/h1&gt;
&lt;p&gt;进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。&lt;/p&gt;
&lt;h4 id=&#34;线程&#34;&gt;线程&lt;/h4&gt;
&lt;p&gt;线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。&lt;/p&gt;
&lt;h4 id=&#34;协程&#34;&gt;协程&lt;/h4&gt;
&lt;p&gt;协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。&lt;/p&gt;
&lt;h2 id=&#34;channel&#34;&gt;channel&lt;/h2&gt;
&lt;h2 id=&#34;select&#34;&gt;select&lt;/h2&gt;
&lt;h2 id=&#34;sync&#34;&gt;sync&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>process</title>
      <link>https://w3xse7en.github.io/docs/os/process/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://w3xse7en.github.io/docs/os/process/</guid>
      <description>&lt;hr&gt;
&lt;h2&gt;目录&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#进程&#34;&gt;进程&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#什么是孤儿进程&#34;&gt;什么是孤儿进程&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#什么是僵尸进程&#34;&gt;什么是僵尸进程&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#进程上下文&#34;&gt;进程上下文&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#内核与用户&#34;&gt;内核与用户&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#进程状态转换&#34;&gt;进程状态转换&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#进程间通信的同步异步-阻塞非阻塞&#34;&gt;进程间通信的同步/异步， 阻塞/非阻塞&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#线程&#34;&gt;线程&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#线程上下文&#34;&gt;线程上下文&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#线程上下文切换耗时比进程大吗&#34;&gt;线程上下文切换耗时比进程大吗？&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#协程&#34;&gt;协程&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#参考&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;hr&gt;
&lt;br&gt;
&lt;h2 id=&#34;进程&#34;&gt;进程&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;进程是资源封装的单位。&lt;/strong&gt; 进程封装的资源包括：内存、文件、文件系统、信号、控制台等等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;在任意时刻， 一个 CPU 核心上（processor）只可能运行一个进程 。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;什么是孤儿进程&#34;&gt;什么是孤儿进程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;当父进程退出时，它的子进程们（一个或者多个）就成了孤儿进程&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当孤儿进程结束后，init进程会释放孤儿进程的资源，因此孤儿进程不会有危害&lt;/p&gt;
&lt;p&gt;一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
由于孤儿进程会被init进程给收养，所以孤儿进程不会对系统造成危害。&lt;/p&gt;
&lt;h3 id=&#34;什么是僵尸进程&#34;&gt;什么是僵尸进程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;子进程先退出，而父进程又没有去处理回收释放子进程的资源，这个时候子进程就成了僵尸进程&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常系统的进程数量都是有限制的，如果有大量的僵尸进程占用进程号，导致新的进程无法创建&lt;/p&gt;
&lt;p&gt;在fork()/execve()过程中，假设子进程结束时父进程仍存在，而父进程fork()之前既没安装SIGCHLD信号处理函数调用waitpid()等待子进程结束，又没有显式忽略该信号，则子进程成为僵死进程，无法正常结束，此时即使是root身份kill -9也不能杀死僵死进程。&lt;/p&gt;
&lt;p&gt;当我们寻求如何消灭系统中大量的僵尸进程时，答案就是把产生大量僵尸进程的那个元凶枪毙掉（通过kill发送SIGTERM或者SIGKILL信号）。枪毙了元凶进程之后，它产生的僵尸进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源。&lt;/p&gt;
&lt;h3 id=&#34;进程上下文&#34;&gt;进程上下文&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;当一个进程在执行时,CPU的所有寄存器中的值、进程的状态以及堆栈中的内容被称为该进程的上下文。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的上下文，以便在再次执行该进程时，能够必得到切换时的状态执行下去。&lt;/p&gt;
&lt;p&gt;在LINUX中，当前进程上下文均保存在进程的任务数据结构中。&lt;/p&gt;
&lt;p&gt;在发生中断时,内核就在被中断进程的上下文中，在内核态下执行中断服务例程。但同时会保留所有需要用到的资源，以便中继服务结束时能恢复被中断进程的执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发生进程上下文切换的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。&lt;/li&gt;
&lt;li&gt;进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。&lt;/li&gt;
&lt;li&gt;当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。&lt;/li&gt;
&lt;li&gt;当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行&lt;/li&gt;
&lt;li&gt;发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;内核与用户&#34;&gt;内核与用户&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。&lt;/p&gt;
&lt;h3 id=&#34;进程状态转换&#34;&gt;进程状态转换&lt;/h3&gt;








  











&lt;figure id=&#34;figure-进程状态轮转图&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/os/process-status-transfer-en.jpg&#34; data-caption=&#34;进程状态轮转图&#34;&gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/os/process-status-transfer-en.jpg&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    进程状态轮转图
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;上图展示了一个进程的不同状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;New. 进程正在被创建.&lt;/li&gt;
&lt;li&gt;Ready. 进程在等待被操作系统调度&lt;/li&gt;
&lt;li&gt;Running. 进程的指令正在被执行&lt;/li&gt;
&lt;li&gt;Waiting. 进程正在等待一些事件的发生（例如 I/O 的完成或者收到某个信号）&lt;/li&gt;
&lt;li&gt;Terminated. 进程执行完毕（可能是被强行终止的）&lt;/li&gt;
&lt;/ul&gt;








  











&lt;figure &gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/os/process-status-transfer-cn.jpg&#34; &gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/os/process-status-transfer-cn.jpg&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;在程序中，创建一个MySQL Client实例，对应创建进程&lt;/li&gt;
&lt;li&gt;MySQL Client启动时会连接MySQL Server，等待MySQL语句执行，对应进程就绪&lt;/li&gt;
&lt;li&gt;使用MySQL Client执行Select语句，对应进程运行&lt;/li&gt;
&lt;li&gt;等待MySQL Server返回Select结果，对应进程阻塞&lt;/li&gt;
&lt;li&gt;Select结果返回后，MySQL Client重新等待语句执行，对应进程就绪&lt;/li&gt;
&lt;li&gt;MySQL Client 执行exit操作，对应进程运行，中止MySQL Client 对应进程中止&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程间通信的同步异步-阻塞非阻塞&#34;&gt;进程间通信的同步/异步， 阻塞/非阻塞&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;进程间的通信是通过 send() 和 receive() 两种基本操作完成的。具体如何实现这两种基础操作，存在着不同的设计。 消息的传递有可能是阻塞的或非阻塞的 – 也被称为同步或异步的&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阻塞式发送（blocking send）发送方进程会被一直阻塞， 直到消息被接受方进程收到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非阻塞式发送（nonblocking send）。发送方进程调用 send() 后， 立即就可以其他操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阻塞式接收（blocking receive） 接收方调用 receive() 后一直阻塞， 直到消息到达可用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非阻塞式接受（nonblocking receive） 接收方调用 receive() 函数后， 要么得到一个有效的结果， 要么得到一个空值， 即不会被阻塞。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;线程&#34;&gt;线程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;线程则是Linux的调度单位，共享同一个进程下的资源。&lt;/strong&gt; Linux内核调度器是以线程为单位进行调度和上下文切换的。&lt;/p&gt;
&lt;h3 id=&#34;线程上下文&#34;&gt;线程上下文&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线程是调度的基本单位，而进程则是资源拥有的基本单位。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说白了，所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。&lt;/p&gt;
&lt;p&gt;所以，对于线程和进程，我们可以这么理解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当进程只有一个线程时，可以认为进程就等于线程。&lt;/li&gt;
&lt;li&gt;当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;发生线程上下文切换的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。&lt;/li&gt;
&lt;li&gt;前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;线程上下文切换耗时比进程大吗&#34;&gt;线程上下文切换耗时比进程大吗？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;从上下文切换的耗时上来看，Linux线程（轻量级进程）其实和进程差别不太大。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;协程&#34;&gt;协程&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/7390f73ad668&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;孤儿进程、僵尸进程和守护进程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://xie.infoq.cn/article/3a980c8f6a5a0a7a26cc3d2e8&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;面试官问：僵尸进程和孤儿进程有了解过吗&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/Anker/p/3269106.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;用户空间与内核空间，进程上下文与中断上下文[总结]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/79772089&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;进程/线程上下文切换会用掉你多少CPU&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>redis</title>
      <link>https://w3xse7en.github.io/docs/sql/redis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://w3xse7en.github.io/docs/sql/redis/</guid>
      <description>&lt;hr&gt;
&lt;h2&gt;目录&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#数据结构&#34;&gt;数据结构&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#redis内部存储结构&#34;&gt;Redis内部存储结构&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#string&#34;&gt;String&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#hash&#34;&gt;Hash&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#rehash&#34;&gt;ReHash&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#skiplist&#34;&gt;SkipList&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#高级数据结构&#34;&gt;高级数据结构&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#缓存&#34;&gt;缓存&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#缓存穿透击穿&#34;&gt;缓存穿透/击穿&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#缓存雪崩&#34;&gt;缓存雪崩&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#热点缓存&#34;&gt;热点缓存&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#布隆过滤器bloom-filter&#34;&gt;布隆过滤器(Bloom Filter)&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#概念&#34;&gt;概念&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#原理&#34;&gt;原理&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#缺点&#34;&gt;缺点&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#分布式锁&#34;&gt;分布式锁&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#为什么要用分布式锁&#34;&gt;为什么要用分布式锁&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#简单的分布式锁实现&#34;&gt;简单的分布式锁实现&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#redlock&#34;&gt;RedLock&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#个人想法&#34;&gt;个人想法&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#持久化&#34;&gt;持久化&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#rdb优缺点&#34;&gt;RDB优缺点&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#aof优缺点&#34;&gt;AOF优缺点&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#同步机制&#34;&gt;同步机制&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#高可用集群&#34;&gt;高可用/集群&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#gossip协议&#34;&gt;Gossip协议&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#redis的分片机制&#34;&gt;Redis的分片机制&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#为什么rediscluster会设计成16384个槽呢&#34;&gt;为什么RedisCluster会设计成16384个槽呢？&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#redis数据增多了是该加内存还是加实例&#34;&gt;Redis数据增多了，是该加内存还是加实例？&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#集群脑裂&#34;&gt;集群脑裂&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#参考&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;hr&gt;
&lt;br&gt;
&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;
&lt;p&gt;String Hash List Set SortedSet。&lt;/p&gt;
&lt;h3 id=&#34;redis内部存储结构&#34;&gt;Redis内部存储结构&lt;/h3&gt;
&lt;p&gt;dictEntry&lt;/p&gt;
&lt;p&gt;因为 Redis 是 KV 的数据库，它是通过 hashtable 实现的（我们把这个叫做外层的哈希）。&lt;/p&gt;
&lt;p&gt;所以每个键值对都会有一个 dictEntry，里面指向了 key 和 value 的指针。next 指向下一个 dictEntry。源码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct dictEntry {
    void *key;              //关键字
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;                    //val
    struct dictEntry *next; //next
} dictEntry;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;key 是字符串，但是 Redis 没有直接使用 C 的字符数组，而是存储在自定义的 SDS中。&lt;/p&gt;
&lt;p&gt;value 既不是直接作为字符串存储，也不是直接存储在 SDS 中，而是存储在redisObject 中。&lt;/p&gt;
&lt;p&gt;实际上五种常用的数据类型的任何一种，都是通过 redisObject 来存储的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct redisObject {
    unsigned type:4; /* 对象的类型， 包括： OBJ_STRING、 OBJ_LIST、 OBJ_HASH、 OBJ_SET、 OBJ_ZSET */
    unsigned encoding:4; /* 具体的数据结构 */
    unsigned lru:LRU_BITS; /* 24 位， 对象最后一次被命令程序访问的时间， 与内存回收有关 */
    int refcount; /* 引用计数。 当 refcount 为 0 的时候， 表示该对象已经不被任何对象引用， 则可以进行垃圾回收了*/
    void *ptr; /* 指向对象实际的数据结构 */
} robj;
&lt;/code&gt;&lt;/pre&gt;








  











&lt;figure &gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/redis/redis_object.jpg&#34; &gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/redis/redis_object.jpg&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h3 id=&#34;string&#34;&gt;String&lt;/h3&gt;
&lt;p&gt;sds是在Redis中被广泛使用的字符串结构，它的全称是Simple Dynamic String。与其它语言环境中出现的字符串相比，它具有如下显著的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;可动态扩展内存。sds表示的字符串其内容可以修改，也可以追加。在很多语言中字符串会分为mutable和immutable两种，显然sds属于mutable类型的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二进制安全（Binary Safe）。sds能存储任意二进制数据，而不仅仅是可打印字符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与传统的C语言字符串类型兼容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;hash&#34;&gt;Hash&lt;/h3&gt;








  











&lt;figure id=&#34;figure-hash链接法&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/redis/hash_dict_jg.png&#34; data-caption=&#34;Hash链接法&#34;&gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/redis/hash_dict_jg.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Hash链接法
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;rehash&#34;&gt;ReHash&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;为ht[1] 分配空间，这个哈希表的空间大小取决于要执行的操作， 以及ht[0]当前包含的键值对数量 （也即是ht[0].used属性的值）：
&lt;ul&gt;
&lt;li&gt;如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；&lt;/li&gt;
&lt;li&gt;如果执行的是收缩操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将rehashidx 初始化为0 ，代表rehash 工作正式开始。&lt;/li&gt;
&lt;li&gt;每次字典进行删除、查找、更新操作时， 会同时在两个hash表上进行（先查找ht[0], 如果没找到，再去查找ht[1]）。 进行添加操作时，会直接添加到ht[1]。&lt;/li&gt;
&lt;li&gt;在进行每次增删改查操作时， 会同时把ht[0] 在rehashidx 索引上的所有键值对都rehash到ht[1]上， 完成后 rehashidx 加1.&lt;/li&gt;
&lt;li&gt;当ht[0] 所有元素都被复制到ht[1]， 设置rehashidx 的值为-1 。&lt;/li&gt;
&lt;li&gt;回收 ht[0]，将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备。。&lt;/li&gt;
&lt;/ol&gt;








  











&lt;figure id=&#34;figure-rehash&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/redis/hash_hashtable_rehash.png&#34; data-caption=&#34;rehash&#34;&gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/redis/hash_hashtable_rehash.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    rehash
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;skiplist&#34;&gt;SkipList&lt;/h3&gt;








  











&lt;figure id=&#34;figure-跳表&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/redis/ziplist_yl.png&#34; data-caption=&#34;跳表&#34;&gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/redis/ziplist_yl.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    跳表
  &lt;/figcaption&gt;


&lt;/figure&gt;









  











&lt;figure id=&#34;figure-跳表查找过程&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/redis/skip_list_search.png&#34; data-caption=&#34;跳表查找过程&#34;&gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/redis/skip_list_search.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    跳表查找过程
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;跳表不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#define ZSKIPLIST_MAXLEVEL 32 
#define ZSKIPLIST_P 0.25 

int zslRandomLevel(void) {
    int level = 1;
    while ((random()&amp;amp;0xFFFF) &amp;lt; (ZSKIPLIST_P * 0xFFFF))
        level += 1;
    return (level&amp;lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行插入操作时计算随机数的过程，是一个很关键的过程，它对skiplist的统计特性有着很重要的影响。&lt;/p&gt;
&lt;p&gt;这并不是一个普通的服从均匀分布的随机数，而是服从一定规则的：&lt;/p&gt;
&lt;p&gt;首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）。
如果一个节点有第i层(i&amp;gt;=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p。
节点最大的层数不允许超过一个最大值，记为MaxLevel（Redis里是32）。
比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。&lt;/p&gt;
&lt;p&gt;下图展示了如何通过一步步的插入操作从而形成一个skiplist的过程：&lt;/p&gt;








  











&lt;figure id=&#34;figure-跳表插入过程&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/redis/skip_list_insert.png&#34; data-caption=&#34;跳表插入过程&#34;&gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/redis/skip_list_insert.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    跳表插入过程
  &lt;/figcaption&gt;


&lt;/figure&gt;









  











&lt;figure id=&#34;figure-跳表&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/redis/skiplist.png&#34; data-caption=&#34;跳表&#34;&gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/redis/skiplist.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    跳表
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h4 id=&#34;为什么跳表层数上限是32&#34;&gt;为什么跳表层数上限是32？&lt;/h4&gt;
&lt;p&gt;根据前面的随机算法当level[0]有2的64次方个节点时，才能达到32层，因此层数上限是32完全够用了。&lt;/p&gt;
&lt;h4 id=&#34;为什么采用跳表而不使用哈希表或平衡树实现&#34;&gt;为什么采用跳表，而不使用哈希表或平衡树实现&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;高级数据结构&#34;&gt;高级数据结构&lt;/h3&gt;
&lt;p&gt;Bitmaps Hyperloglogs GEO&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HyperLogLog是用于计算唯一事物的概率数据结构（从技术上讲，这被称为估计集合的基数）。
如果统计唯一项，项目越多，需要的内存就越多。因为需要记住过去已经看过的项，从而避免多次统计这些项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GEO可以将用户给定的地理位置（经度和纬度）信息储存起来，并对这些信息进行操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;hr&gt;
&lt;h2 id=&#34;缓存&#34;&gt;缓存&lt;/h2&gt;
&lt;h3 id=&#34;缓存穿透击穿&#34;&gt;缓存穿透/击穿&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;查询一个数据库中不存在的数据，请求会越过Redis，直接请求DB。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;做好防高频请求
非正常用户量的请求，10s内发起1000次请求
对于此请求的ip进行验证码校验，或者封禁处理&lt;/p&gt;
&lt;p&gt;接口参数合法性校验
请求id需要&amp;gt;=0,分页每页最多100条等&lt;/p&gt;
&lt;p&gt;将此key对应的value设置为一个默认的值，并设置相对短的失效时间例如30分钟&lt;/p&gt;
&lt;p&gt;使用&lt;a href=&#34;https://w3xse7en.github.io/docs/sql/redis/#布隆过滤器(Bloom Filter)&#34;&gt;布隆过滤器(Bloom Filter)&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;缓存雪崩&#34;&gt;缓存雪崩&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;大量Key同时失效，又有大量请求同时到来，导致请求冲向DB，DB最终卡死。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;处理缓存雪崩，在批量往Redis存数据的时候，把每个Key的失效时间都加个随机值，这样可以保证Key不会在同一时间大面积失效&lt;/p&gt;
&lt;h3 id=&#34;热点缓存&#34;&gt;热点缓存&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;某个Key过热，压力集中到一台Redis上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用多级缓存机制，将过热的Key分散到各个服务器的本地缓存中，降低过热Key所在的Redis节点的压力，其他的Key依旧由分布式Redis集群承担&lt;/p&gt;
&lt;br&gt;
&lt;hr&gt;
&lt;h2 id=&#34;布隆过滤器bloom-filter&#34;&gt;布隆过滤器(Bloom Filter)&lt;/h2&gt;
&lt;h3 id=&#34;概念&#34;&gt;概念&lt;/h3&gt;
&lt;p&gt;布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。&lt;/p&gt;
&lt;h3 id=&#34;原理&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。&lt;/p&gt;
&lt;p&gt;检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了&lt;/p&gt;
&lt;p&gt;如果这些点有任何一个0，则被检元素一定不在&lt;/p&gt;
&lt;p&gt;如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。&lt;/p&gt;
&lt;p&gt;Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。&lt;/p&gt;








  











&lt;figure id=&#34;figure-bloom-filter&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/redis/Bloom-Filter.jpg&#34; data-caption=&#34;Bloom Filter&#34;&gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/redis/Bloom-Filter.jpg&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Bloom Filter
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;缺点&#34;&gt;缺点&lt;/h3&gt;
&lt;p&gt;bloom filter之所以能做到在时间和空间上的效率比较高，是因为牺牲了判断的准确率、删除的便利性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1。如果bloom filter中存储的是黑名单，那么可以通过建立一个白名单来存储可能会误判的元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除困难。一个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为0，可能会影响其他元素的判断。可以采用Counting Bloom Filter&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;hr&gt;
&lt;h2 id=&#34;分布式锁&#34;&gt;分布式锁&lt;/h2&gt;
&lt;h3 id=&#34;为什么要用分布式锁&#34;&gt;为什么要用分布式锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Efficiency（效率） 在分布式系统中，避免不同节点重复做相同的工作，节约计算机资源。&lt;/li&gt;
&lt;li&gt;Correctness（正确) 避免不同节点并发处理同一段数据时，相互干扰结果。例如对一个订单同时进行不同流程，最终订单状态出现混乱&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;简单的分布式锁实现&#34;&gt;简单的分布式锁实现&lt;/h3&gt;
&lt;p&gt;单节点Redis&lt;/p&gt;
&lt;p&gt;简单实现，可以使用 &lt;code&gt;SET key value PX milliseoncds NX&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个方案会引申出两个问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;锁从master复制到slave的时候挂了，会出现同一资源被多个client加锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行时间超过了锁的过期时间。很难保证任务一定能在锁的过期时间内完成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;redlock&#34;&gt;RedLock&lt;/h3&gt;
&lt;p&gt;Redlock算法是Antirez在单Redis节点基础上引入的高可用模式。&lt;/p&gt;
&lt;p&gt;在Redis的分布式环境中，我们假设有N个完全互相独立的Redis节点，在N个Redis实例上使用与在Redis单实例下相同方法获取锁和释放锁。&lt;/p&gt;
&lt;p&gt;现在假设有5个Redis主节点(大于3的奇数个)，这样基本保证他们不会同时都宕掉。&lt;/p&gt;
&lt;p&gt;获取锁和释放锁的过程中，客户端会执行以下操作:&lt;/p&gt;
&lt;p&gt;1.获取当前Unix时间，以毫秒为单位&lt;/p&gt;
&lt;p&gt;2.依次尝试从5个实例，使用相同的key和具有唯一性的value获取锁当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间，这样可以避免客户端死等&lt;/p&gt;
&lt;p&gt;3.客户端使用当前时间减去开始获取锁时间就得到获取锁使用的时间。当且仅当从半数以上的Redis节点取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功&lt;/p&gt;
&lt;p&gt;4.如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间，这个很重要&lt;/p&gt;
&lt;p&gt;5.如果因为某些原因，获取锁失败（没有在半数以上实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁，无论Redis实例是否加锁成功，因为可能服务端响应消息丢失了但是实际成功了，毕竟多释放一次也不会有问题&lt;/p&gt;
&lt;h3 id=&#34;个人想法&#34;&gt;个人想法&lt;/h3&gt;
&lt;p&gt;能不用分布式锁就不用分布式锁，避免引入新的复杂度，对于需要使用锁的场景，优先基于中间件原子性的机制操作。&lt;/p&gt;
&lt;p&gt;MySQL数据库，加上version字段，强制要求所有update语句带上&lt;code&gt;set version=version+1 where version={old_version}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可能重复insert的场景，对合理的业务id加上唯一索引，由数据库自有机制保证不会有重复数据插入&lt;/p&gt;
&lt;p&gt;秒杀，统计等场景，使用Redis的incr,decr语句来替代分布式锁操作库存&lt;/p&gt;
&lt;br&gt;
&lt;hr&gt;
&lt;h2 id=&#34;持久化&#34;&gt;持久化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。（适合冷备）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。
AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。（适合热备）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。&lt;/p&gt;
&lt;p&gt;Redis 还可以同时使用 AOF 持久化和 RDB 持久化。
在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。&lt;/p&gt;
&lt;p&gt;但实际上持久化会对Redis的性能造成非常严重的影响，如果一定需要保存数据，那么数据就不应该依靠缓存来保存，建议使用其他方式如数据库。所以Redis的持久化意义不大。&lt;/p&gt;
&lt;h3 id=&#34;rdb优缺点&#34;&gt;RDB优缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;优点：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他会生成多个数据文件，每个数据文件分别都代表了某一时刻Redis里面的数据，这种方式，适合做冷备。&lt;/p&gt;
&lt;p&gt;RDB对Redis的性能影响非常小，是因为在同步数据的时候他只是fork了一个子进程去做持久化的，而且他在数据恢复的时候速度比AOF来的快。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缺点：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RDB都是快照文件，都是默认五分钟甚至更久的时间才会生成一次，这意味着你这次同步到下次同步这中间五分钟的数据都很可能全部丢失掉。&lt;/p&gt;
&lt;p&gt;RDB在生成数据快照的时候，如果文件很大，客户端可能会暂停几毫秒甚至几秒。&lt;/p&gt;
&lt;h3 id=&#34;aof优缺点&#34;&gt;AOF优缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;优点：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RDB五分钟一次生成快照，但是AOF是一秒一次去通过一个后台的线程fsync操作，那最多丢这一秒的数据。&lt;/p&gt;
&lt;p&gt;AOF在对日志文件进行操作的时候是以append-only的方式去写的，他只是追加的方式写数据，自然就少了很多磁盘寻址的开销了，写入性能惊人，文件也不容易破损。&lt;/p&gt;
&lt;p&gt;AOF的日志是通过一个叫非常可读的方式记录的，这样的特性就适合做灾难性数据误删除的紧急恢复了，比如公司的实习生通过flushall清空了所有的数据，只要这个时候后台重写还没发生，你马上拷贝一份AOF日志文件，把最后一条flushall命令删了就完事了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缺点：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一样的数据，AOF文件比RDB还要大。&lt;/p&gt;
&lt;p&gt;AOF开启后，Redis支持写的QPS会比RDB支持写的要低。&lt;/p&gt;
&lt;h3 id=&#34;同步机制&#34;&gt;同步机制&lt;/h3&gt;
&lt;p&gt;Redis可以使用主从同步，从从同步。&lt;/p&gt;
&lt;p&gt;第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。&lt;/p&gt;
&lt;p&gt;加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。&lt;/p&gt;
&lt;p&gt;后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。&lt;/p&gt;
&lt;br&gt;
&lt;hr&gt;
&lt;h2 id=&#34;高可用集群&#34;&gt;高可用/集群&lt;/h2&gt;
&lt;p&gt;Redis Sentinal 着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。&lt;/p&gt;
&lt;p&gt;Redis Cluster 着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。&lt;/p&gt;
&lt;h3 id=&#34;gossip协议&#34;&gt;Gossip协议&lt;/h3&gt;
&lt;p&gt;Gossip算法又被称为反熵（Anti-Entropy），熵是物理学上的一个概念，代表杂乱无章，而反熵就是在杂乱无章中寻求一致&lt;/p&gt;
&lt;p&gt;这充分说明了Gossip的特点：在一个有界网络中，每个节点都随机地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。&lt;/p&gt;
&lt;p&gt;每个节点可能知道所有其他节点，也可能仅知道几个邻居节点，只要这些节可以通过网络连通，最终他们的状态都是一致的&lt;/p&gt;
&lt;p&gt;Redis Gossip消息分为消息头和消息体，消息体一共有4类，其中MEET、PING和PONG消息都用clusterMsgDataGossip结构来表示。&lt;/p&gt;
&lt;p&gt;随机周期性发送PING消息&lt;/p&gt;








  











&lt;figure id=&#34;figure-gossip协议下一种可能的消息传播过程&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/redis/gossip.gif&#34; data-caption=&#34;Gossip协议下一种可能的消息传播过程&#34;&gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/redis/gossip.gif&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Gossip协议下一种可能的消息传播过程
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;redis的分片机制&#34;&gt;Redis的分片机制&lt;/h3&gt;
&lt;p&gt;Redis 集群没有使用一致性hash, 而是引入了哈希槽的概念。&lt;/p&gt;
&lt;p&gt;Redis Cluster 采用虚拟哈希槽分区，所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，每个key通过CRC16校验后对16384取模来决定放置哪个槽(Slot)，每一个节点负责维护一部分槽以及槽所映射的键值数据。&lt;/p&gt;
&lt;p&gt;计算公式：slot = CRC16(key) &amp;amp; 16383。&lt;/p&gt;
&lt;p&gt;这种结构很容易添加或者删除节点，并且无论是添加删除或者修改某一个节点，都不会造成集群不可用的状态。使用哈希槽的好处就在于可以方便的添加或移除节点。&lt;/p&gt;
&lt;p&gt;当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；&lt;/p&gt;
&lt;p&gt;当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了。&lt;/p&gt;
&lt;h3 id=&#34;为什么rediscluster会设计成16384个槽呢&#34;&gt;为什么RedisCluster会设计成16384个槽呢？&lt;/h3&gt;
&lt;p&gt;1.如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大。&lt;/p&gt;
&lt;p&gt;如上所述，在消息头中，最占空间的是 slots[CLUSTER_SLOTS/8]。 当槽位为65536时，这块的大小是: 65536÷8÷1024=8kb因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。&lt;/p&gt;
&lt;p&gt;2.redis的集群主节点数量基本不可能超过1000个。&lt;/p&gt;
&lt;p&gt;如上所述，集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者，不建议redis cluster节点数量超过1000个。 那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。&lt;/p&gt;
&lt;p&gt;3.槽位越小，节点少的情况下，压缩率高&lt;/p&gt;
&lt;p&gt;Redis主节点的配置信息中，它所负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中，会对bitmap进行压缩，但是如果bitmap的填充率slots / N很高的话(N表示节点数)，bitmap的压缩率就很低。 如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。&lt;/p&gt;
&lt;h3 id=&#34;redis数据增多了是该加内存还是加实例&#34;&gt;Redis数据增多了，是该加内存还是加实例？&lt;/h3&gt;
&lt;p&gt;这跟 Redis 的持久化机制有关系。&lt;/p&gt;
&lt;p&gt;在使用 RDB 进行持久化时，Redis 会 fork 子进程来完成，fork 操作的用时和 Redis 的数据量是正相关的，而 fork 在执行时会阻塞主线程。&lt;/p&gt;
&lt;p&gt;数据量越大，fork 操作造成的主线程阻塞的时间越长。所以，在使用 RDB 对 25GB 的数据进行持久化时，数据量较大，后台运行的子进程在 fork 创建时阻塞了主线程，于是就导致 Redis 响应变慢了。&lt;/p&gt;
&lt;h3 id=&#34;集群脑裂&#34;&gt;集群脑裂&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;min-replicas-to-write 3
min-replicas-max-lag 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要求至少3个slave节点，且数据复制和同步的延迟不能超过10秒。否则master就拒绝读写，这样发生集群脑裂原先的master节点接收到写入请求就会拒绝&lt;/p&gt;
&lt;h4 id=&#34;raft协议解决脑裂&#34;&gt;Raft协议解决脑裂&lt;/h4&gt;
&lt;p&gt;选举安全性，即在一个任期内最多一个领导人被选出，如果有多余的领导人被选出，则被称为脑裂（brain split），如果出现脑裂会导致数据的丢失或者覆盖。&lt;/p&gt;
&lt;p&gt;Raft通过下面两点保证了不会出现脑裂的情况；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个节点某一任期内最多只能投一票；&lt;/li&gt;
&lt;li&gt;只有获得大多数选票才能成为领导人；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过增加约束避免了脑裂的情况出现，保证了同一时间集群中只有一个领导者。&lt;/p&gt;
&lt;p&gt;但是当一个节点崩溃了一段时间，他的状态机已经落后其他节点很多，突然他重启恢复被选举为领导者，这个时候，客户端发来的请求再经由他复制给其他节点的状态机执行，就会出现集群状态机状态不一致的问题。&lt;/p&gt;
&lt;br/&gt;
&lt;hr&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://itzones.cn/2020/06/30/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8BHash/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Redis基本数据类型之Hash&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844903446475177998&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Redis 为什么用跳表而不用平衡树？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844903433716105224&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Redis 内部数据结构详解 (2)——sds&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://itzones.cn/2020/07/11/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8BZSet/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Redis基本数据类型之ZSet&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844904039218429960&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于Redis的分布式锁和Redlock算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/javagrowing/JGrowing/blob/master/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%86%8D%E6%9C%89%E4%BA%BA%E9%97%AE%E4%BD%A0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E6%89%94%E7%BB%99%E4%BB%96.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;再有人问你分布式锁，这篇文章扔给他&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/b52336ebfc43&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;漫谈Gossip协议与其在Redis Cluster中的实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/308641354&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;redis集群中的gossip协议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://qyuan.top/2019/07/16/raft-1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;分布式一致性协议之Raft(二)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1Fi4y147ad&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;动画演示 raft 在脑裂发生之后仍然可以正常工作吗？&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>socket</title>
      <link>https://w3xse7en.github.io/docs/web/socket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://w3xse7en.github.io/docs/web/socket/</guid>
      <description>&lt;hr&gt;
&lt;h2&gt;目录&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#io模型&#34;&gt;I/O模型&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#blocking-io---阻塞io&#34;&gt;Blocking I/O - 阻塞I/O&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#nonblocking-io---非阻塞io&#34;&gt;Nonblocking I/O - 非阻塞I/O&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#io-multiplexing---io多路复用&#34;&gt;I/O Multiplexing - I/O多路复用&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#signal-driven-io----信号驱动io&#34;&gt;Signal-Driven I/O  - 信号驱动I/O&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#asynchronous-io---异步io&#34;&gt;Asynchronous I/O - 异步I/O&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#五种-io-模型比较&#34;&gt;五种 I/O 模型比较&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#select&#34;&gt;select&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#select遇到的问题&#34;&gt;select遇到的问题&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#epoll&#34;&gt;epoll&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#epoll是如何解决select的三个问题&#34;&gt;epoll是如何解决select的三个问题&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#epoll的伪码描述&#34;&gt;epoll的伪码描述&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#参考&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;hr&gt;
&lt;br&gt;
&lt;h2 id=&#34;io模型&#34;&gt;I/O模型&lt;/h2&gt;
&lt;p&gt;[UNIX: registered: Network Programming] 提供了5种IO模型&lt;/p&gt;
&lt;h3 id=&#34;blocking-io---阻塞io&#34;&gt;Blocking I/O - 阻塞I/O&lt;/h3&gt;








  











&lt;figure &gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/os/block-io.png&#34; &gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/os/block-io.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h3 id=&#34;nonblocking-io---非阻塞io&#34;&gt;Nonblocking I/O - 非阻塞I/O&lt;/h3&gt;








  











&lt;figure &gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/os/nonblock-io.png&#34; &gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/os/nonblock-io.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h3 id=&#34;io-multiplexing---io多路复用&#34;&gt;I/O Multiplexing - I/O多路复用&lt;/h3&gt;








  











&lt;figure &gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/os/io-multiplexing.png&#34; &gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/os/io-multiplexing.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h3 id=&#34;signal-driven-io----信号驱动io&#34;&gt;Signal-Driven I/O  - 信号驱动I/O&lt;/h3&gt;








  











&lt;figure &gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/os/signal-driven-io.png&#34; &gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/os/signal-driven-io.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h3 id=&#34;asynchronous-io---异步io&#34;&gt;Asynchronous I/O - 异步I/O&lt;/h3&gt;








  











&lt;figure &gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/os/asynchronous-io.png&#34; &gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/os/asynchronous-io.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h3 id=&#34;五种-io-模型比较&#34;&gt;五种 I/O 模型比较&lt;/h3&gt;








  











&lt;figure &gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/os/compare-five-io.png&#34; &gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/os/compare-five-io.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;h2 id=&#34;select&#34;&gt;select&lt;/h2&gt;
&lt;p&gt;io多路复用是为了解决一个进程同时处理多个socket问题&lt;/p&gt;
&lt;p&gt;一个简单的思路是&lt;/p&gt;
&lt;p&gt;假设有N个socket链接，检测有socket接收到数据，遍历所有socket进行处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// fds = file decriptors
for {
    select (fds) // wait while fds poll callback POLL_IN
    for fd range fds{
        if fd has data{
            read fd
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;被监控的fds需要从用户空间拷贝到内核空间
为了减少数据拷贝带来的性能损坏，内核对被监控的fds集合大小做了限制，并且这个是通过宏控制的，大小不可改变(限制为1024)。&lt;/li&gt;
&lt;li&gt;被监控的fds集合中，只要有一个有数据可读，整个socket集合就会被遍历一次调用sk的poll函数收集可读事件
由于当初的需求是朴素，仅仅关心是否有数据可读这样一个事件，当事件通知来的时候，由于数据的到来是异步的，我们不知道事件来的时候，有多少个被监控的socket有数据可读了，于是，只能挨个遍历每个socket来收集可读事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;select遇到的问题&#34;&gt;select遇到的问题&lt;/h3&gt;
&lt;p&gt;总共有三个问题需要解决&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;被监控的fds集合大小被限制了1024，不够用&lt;/li&gt;
&lt;li&gt;fds集合需要从用户空间拷贝到内核空间的问题，耗费性能&lt;/li&gt;
&lt;li&gt;需要遍历fds集合才能知道有数据接收的fds列表&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;epoll&#34;&gt;epoll&lt;/h2&gt;
&lt;p&gt;epoll 是对 select 和 poll 的改进，避免了“性能开销大”和“文件描述符数量少”两个缺点。&lt;/p&gt;
&lt;p&gt;epoll 有以下几个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;strong&gt;红黑树&lt;/strong&gt;存储文件描述符集合&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;队列&lt;/strong&gt;存储就绪的文件描述符&lt;/li&gt;
&lt;li&gt;每个文件描述符只需在添加时传入一次；通过事件更改文件描述符状态&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;epoll一共有3个接口&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;epoll_create创建epoll实例，其实例内部存储：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;监听列表：所有要监听的文件描述符，使用&lt;strong&gt;红黑树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就绪列表：所有就绪的文件描述符，使用&lt;strong&gt;队列&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;epoll_ctl用来维护监视列表，可以添加或删除所要监听的 socket&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;epoll_ctl 会将文件描述符 fd 添加到 epoll 实例的监听列表里，同时为 fd 设置一个回调函数，并监听事件event。当fd上发生相应事件时，会调用回调函数，将 fd 添加到 epoll 实例的就绪队列上。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;当调用epoll_wait时，如果就绪列表中存在socket，则直接返回，如果没有，则阻塞进程&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;epoll是如何解决select的三个问题&#34;&gt;epoll是如何解决select的三个问题&lt;/h3&gt;
&lt;details&gt;
  &lt;summary&gt;被监控的fds集合大小被限制了1024，不够用&lt;/summary&gt;
&lt;p&gt;select 使用整型数组存储文件描述符集合，而 epoll 使用红黑树存储，数量较大。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
  &lt;summary&gt;fds集合需要从用户空间拷贝到内核空间的问题，耗费性能&lt;/summary&gt;
&lt;p&gt;epoll通过内核与用户空间使用mmap(内存映射)，将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址，减少用户态和内核态之间的数据交换。&lt;/p&gt;
&lt;p&gt;epoll 对于每个描述符，只需要在 epoll_ctl 传递一次，之后 epoll_wait 不需要再次传递这也大大提高了效率。&lt;/p&gt;
&lt;/details&gt;
&lt;details&gt;
  &lt;summary&gt;需要遍历fds集合才能知道有数据接收的fds列表&lt;/summary&gt;
&lt;p&gt;epoll_ctl 中为每个文件描述符指定了回调函数，并在就绪时将其加入到就绪列表，因此 epoll 不需要像 select 那样遍历检测每个文件描述符，只需要判断就绪列表是否为空即可。这样，在没有描述符就绪时，epoll 能更早地让出系统资源。&lt;/p&gt;
&lt;p&gt;相当于时间复杂度从 O(n) 降为 O(1)&lt;/p&gt;
&lt;/details&gt;
&lt;h3 id=&#34;epoll的伪码描述&#34;&gt;epoll的伪码描述&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;for{
    active_fd = epoll_wait(fds)
    read fd
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://notes.shichao.io/unp/ch6/#signal-driven-io-model&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chapter 6. I/O Multiplexing: The select and poll Functions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Socket&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://imageslr.github.io/2020/02/27/select-poll-epoll.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;【操作系统】I/O 多路复用，select / poll / epoll 详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/19732473/answer/241673170&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;怎样理解阻塞非阻塞与同步异步的区别&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1005481&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;大话 Select、Poll、Epoll&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://gityuan.com/2019/01/06/linux-epoll/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;源码解读epoll内核机制&lt;/a&gt;&lt;/p&gt;
&lt;br/&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Q&amp;A</title>
      <link>https://w3xse7en.github.io/docs/lang/qa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://w3xse7en.github.io/docs/lang/qa/</guid>
      <description>&lt;h1 id=&#34;qa&#34;&gt;Q&amp;amp;A&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>hyper-v 安装 centos</title>
      <link>https://w3xse7en.github.io/k8s_local/10_hyper-v_install_centos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://w3xse7en.github.io/k8s_local/10_hyper-v_install_centos/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;centos&#34;&gt;Centos&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/centos/7.8.2003/isos/x86_64/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;清华大学centos7.8.2003镜像&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;








  











&lt;figure id=&#34;figure-清华大学镜像站&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/k8s_local/1-tsinghua-mirror.png&#34; data-caption=&#34;清华大学镜像站&#34;&gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/k8s_local/1-tsinghua-mirror.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    清华大学镜像站
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h2 id=&#34;虚拟机&#34;&gt;虚拟机&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;宿主机i5-6200u 2c16g&lt;/li&gt;
&lt;li&gt;每台机器均为2c4g配置&lt;/li&gt;
&lt;/ul&gt;








  











&lt;figure id=&#34;figure-hyper-v&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/k8s_local/2-hyper-v.png&#34; data-caption=&#34;hyper-v&#34;&gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/k8s_local/2-hyper-v.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    hyper-v
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h2 id=&#34;网络&#34;&gt;网络&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;安装完的centos是不能上网的&lt;/li&gt;
&lt;li&gt;此处使用桥接模式进行网络连接&lt;/li&gt;
&lt;li&gt;使用桥接模式 使node和host处在同一网段更方便其他设备访问&lt;/li&gt;
&lt;/ul&gt;








  











&lt;figure &gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/k8s_local/3-net-bridge.png&#34; &gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/k8s_local/3-net-bridge.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;



&lt;/figure&gt;









  











&lt;figure id=&#34;figure-桥接详情&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/k8s_local/4-bridge-info.png&#34; data-caption=&#34;桥接详情&#34;&gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/k8s_local/4-bridge-info.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    桥接详情
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;配置Centos 静态ip地址&lt;/li&gt;
&lt;li&gt;网段参考网桥ip&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;vi /etc/sysconfig/network-scripts/ifcfg-eth0

ONBOOT=yes
BOOTPROTO=static
IPADDR=192.168.1.201
NETMASK=255.255.255.0
GATEWAY=192.168.1.1
DNS1=192.168.1.1

service network restart
&lt;/code&gt;&lt;/pre&gt;








  











&lt;figure id=&#34;figure-网络拓扑图&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/k8s_local/5-net.png&#34; data-caption=&#34;网络拓扑图&#34;&gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/k8s_local/5-net.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    网络拓扑图
  &lt;/figcaption&gt;


&lt;/figure&gt;

</description>
    </item>
    
    <item>
      <title>kubespray 安装 k8s</title>
      <link>https://w3xse7en.github.io/k8s_local/20_install_k8s/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://w3xse7en.github.io/k8s_local/20_install_k8s/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://kubespray.io/#/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;kubespray&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=8Jh4yZQOVZU&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;[ Kube 65.1 ] Kubespray - Kubernetes cluster provisioning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=CJ5G4GpqDy0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Deploying kubernetes using Kubespray&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.d-nix.nl/2019/05/installing-a-multinode-kubernetes-cluster-using-kubespray/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;INSTALLING A MULTINODE KUBERNETES CLUSTER USING KUBESPRAY&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes-sigs/kubespray/issues/6207&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;it&amp;rsquo;s really really really hard run kubespray in china! #6207&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bookstack.cn/read/huweihuang-kubernetes-notes/setup-install-k8s-by-kubespray.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用kubespray安装kubernetes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bboy.app/2020/07/20/%E4%BD%BF%E7%94%A8kubespray%E6%90%AD%E5%BB%BA%E7%94%9F%E4%BA%A7%E7%BA%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用kubespray搭建生产级高可用集群&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000015186299&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;使用Kubespray安装k8s集群&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;docker/kubernetes%e5%9b%bd%e5%86%85%e6%ba%90/%e9%95%9c%e5%83%8f%e6%ba%90%e8%a7%a3%e5%86%b3%e6%96%b9%e5%bc%8f&#34;&gt;docker/kubernetes国内源/镜像源解决方式&lt;/a&gt;&lt;/p&gt;
&lt;br/&gt;
&lt;hr&gt;
&lt;h2 id=&#34;配置免密码登录&#34;&gt;配置免密码登录&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ssh-keygen -t rsa
ssh-copy-id root@192.168.1.200
ssh-copy-id root@192.168.1.201
ssh-copy-id root@192.168.1.202
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
&lt;h2 id=&#34;下载kubespray&#34;&gt;下载kubespray&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# master分支还在更新中，此处使用当前最新release的版本v2.14.1
git clone --single-branch -b v2.14.1 https://github.com/kubernetes-sigs/kubespray.git
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
&lt;h2 id=&#34;安装python3-pip&#34;&gt;安装python3-pip&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;yum install python3-pip
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
&lt;h2 id=&#34;安装kubespray依赖&#34;&gt;安装kubespray依赖&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pip3 install -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple/
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
&lt;h2 id=&#34;使用ansible对每台机器进行批处理&#34;&gt;使用ansible对每台机器进行批处理&lt;/h2&gt;
&lt;p&gt;配置ansible访问k8s集群hosts&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vi /etc/ansible/hosts
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[k8s]

192.168.1.200 ansible_ssh_user=root
192.168.1.201 ansible_ssh_user=root
192.168.1.202 ansible_ssh_user=root
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ansible k8s -m ping
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;更新yum&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ansible k8s -m shell -a &#39;yum update -y&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;安装ntp服务，统一集群时间&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ansible k8s -m shell -a &#39;yum install -y ntp &amp;amp;&amp;amp;
systemctl enable ntpd &amp;amp;&amp;amp;
systemctl start ntpd &amp;amp;&amp;amp;
timedatectl set-timezone Asia/Shanghai &amp;amp;&amp;amp;
timedatectl set-ntp yes &amp;amp;&amp;amp; 
ntpq -p&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;配置ipv4转发&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ansible k8s -m shell -a &#39;echo net.ipv4.ip_forward = 1 &amp;gt;&amp;gt; /etc/sysctl.conf &amp;amp;&amp;amp; sysctl -p&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;关闭防火墙&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ansible k8s -m shell -a &#39;systemctl stop firewalld &amp;amp;&amp;amp; systemctl disable firewalld&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
&lt;h2 id=&#34;生成kubespray所需配置&#34;&gt;生成kubespray所需配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;创建可自定义的配置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cp -rfp inventory/sample inventory/mycluster
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;IPS=(此处填写k8s集群的ip地址，注意&lt;code&gt;空格&lt;/code&gt;分割)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;declare -a IPS=(192.168.1.200 192.168.1.201 192.168.1.202)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;CONFIG_FILE=inventory/mycluster/hosts.yaml python3 contrib/inventory_builder/inventory.py ${IPS[@]}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看生成的hosts.yaml&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat inventory/mycluster/hosts.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;此处是 2个master 3个node 3个etcd 的高可用配置，可以根据喜好进行配置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;all:
  hosts:
    node1:
      ansible_host: 192.168.1.200
      ip: 192.168.1.200
      access_ip: 192.168.1.200
    node2:
      ansible_host: 192.168.1.201
      ip: 192.168.1.201
      access_ip: 192.168.1.201
    node3:
      ansible_host: 192.168.1.202
      ip: 192.168.1.202
      access_ip: 192.168.1.202
  children:
    kube-master:
      hosts:
        node1:
        node2:
    kube-node:
      hosts:
        node1:
        node2:
        node3:
    etcd:
      hosts:
        node1:
        node2:
        node3:
    k8s-cluster:
      children:
        kube-master:
        kube-node:
    calico-rr:
      hosts: {}
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
&lt;h2 id=&#34;下载依赖&#34;&gt;下载依赖&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方案1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bboy.app/2020/07/20/%E4%BD%BF%E7%94%A8kubespray%E6%90%AD%E5%BB%BA%E7%94%9F%E4%BA%A7%E7%BA%A7%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;将所有源换成国内镜像加速&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方案2&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes-sigs/kubespray/issues/6207&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;离线安装&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方案3&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置代理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此处使用方案3&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vi inventory/mycluster/group_vars/all/all.yml

http_proxy: &amp;quot;http://192.168.1.9:1080&amp;quot;
https_proxy: &amp;quot;http://192.168.1.9:1080&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在阿里云环境下使用代理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开启自己电脑上的http proxy server&lt;/li&gt;
&lt;li&gt;使用&lt;a href=&#34;https://github.com/fatedier/frp&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;frp&lt;/a&gt;将本地电脑http proxy port 映射至公网&lt;/li&gt;
&lt;li&gt;配置http_proxy&lt;/li&gt;
&lt;li&gt;直接在阿里云内使用代理可能会被警告，因此使用frp做一层中转&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置docker镜像源&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vi inventory/mycluster/group_vars/all/docker.yml
## Add other registry,example China registry mirror.
docker_registry_mirrors:
  - https://mirror.aliyuncs.com
  - https://registry.docker-cn.com
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;提前下载k8s所需依赖，避免安装时报错&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ansible-playbook -i inventory/mycluster/hosts.yaml  --become --become-user=root cluster.yml --tags container_engine

ansible-playbook -i inventory/mycluster/hosts.yaml  --become --become-user=root cluster.yml --tags download
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;若遇到报错，可尝试将http_proxy注释掉重新下载，重复试几次后一般都能下完
&lt;ul&gt;
&lt;li&gt;阿里云apt, yum等源设置的是内网地址，需要直连才可以访问&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vi inventory/mycluster/group_vars/all/all.yml

# http_proxy: &amp;quot;http://192.168.1.9:1080&amp;quot;
# https_proxy: &amp;quot;http://192.168.1.9:1080&amp;quot;
&lt;/code&gt;&lt;/pre&gt;








  











&lt;figure id=&#34;figure-frp-v2ray-代理下载&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/k8s_local/frp-v2ray-proxy.png&#34; data-caption=&#34;frp-v2ray-代理下载&#34;&gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/k8s_local/frp-v2ray-proxy.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    frp-v2ray-代理下载
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    ubuntu 系统安装完毕后，请删除&lt;code&gt;/etc/apt/apt.conf&lt;/code&gt;里的代理配置
  &lt;/div&gt;
&lt;/div&gt;
&lt;br/&gt;
&lt;h2 id=&#34;可选开启helm&#34;&gt;(可选)开启helm&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vi inventory/mycluster/group_vars/k8s-cluster/addons.yml
# Helm deployment
helm_enabled: true
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ansible-playbook -i inventory/mycluster/hosts.yaml  --become --become-user=root cluster.yml
&lt;/code&gt;&lt;/pre&gt;








  











&lt;figure id=&#34;figure-安装花费21分钟&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/k8s_local/6-install.png&#34; data-caption=&#34;安装花费21分钟&#34;&gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/k8s_local/6-install.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    安装花费21分钟
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;br/&gt;
&lt;h2 id=&#34;验证&#34;&gt;验证&lt;/h2&gt;








  











&lt;figure id=&#34;figure-k8s-v1189安装成功&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://w3xse7en.github.io/media/k8s_local/7-check.png&#34; data-caption=&#34;k8s v1.18.9安装成功&#34;&gt;


  &lt;img src=&#34;https://w3xse7en.github.io/media/k8s_local/7-check.png&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    k8s v1.18.9安装成功
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;br/&gt;
&lt;h2 id=&#34;重置&#34;&gt;重置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;若在安装过程中遇到问题可用以下命令重置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ansible-playbook -i inventory/mycluster/hosts.yaml reset.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
&lt;h2 id=&#34;dashboard&#34;&gt;Dashboard&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Kubespray并没有替你创建用户，所以需要创建用户，然后获得Token，使用Token登录。&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;ul&gt;
&lt;li&gt;添加admin-user用户&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat &amp;lt;&amp;lt;EOF | kubectl apply -f -
apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin-user
  namespace: kube-system

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: admin-user
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: admin-user
  namespace: kube-system
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;获取admin-user的token&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk &#39;{print $1}&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;访问dashboard&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;https://192.168.1.200:6443/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/login
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;code&gt;services &amp;quot;https:kubernetes-dashboard:&amp;quot; is forbidden: User &amp;quot;system:anonymous&amp;quot; cannot get services/proxy in the namespace &amp;quot;kube-system&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;遇到此问题请查看&lt;a href=&#34;https://w3xse7en.github.io/k8s_local/999_qa/#system:anonymous-%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE-k8s-dashboard&#34;&gt;system:anonymous 无法访问 k8s dashboard&lt;/a&gt;&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>添加/删除节点</title>
      <link>https://w3xse7en.github.io/k8s_local/30_add_remove_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://w3xse7en.github.io/k8s_local/30_add_remove_node/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes-sigs/kubespray/blob/master/docs/getting-started.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;kubespray&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=duAvUhNydh4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;[ Kube 65.3 ] Kubespray - Adding &amp;amp; Removing Kubernetes nodes&lt;/a&gt;&lt;/p&gt;
&lt;br/&gt;
&lt;hr&gt;
&lt;h2 id=&#34;添加节点&#34;&gt;添加节点&lt;/h2&gt;
&lt;h3 id=&#34;配置ansible访问新节点1921681203&#34;&gt;配置ansible访问新节点(192.168.1.203)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vi /etc/ansible/hosts
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[k8s]

192.168.1.200 ansible_ssh_user=root
192.168.1.201 ansible_ssh_user=root
192.168.1.202 ansible_ssh_user=root
192.168.1.203 ansible_ssh_user=root
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ansible k8s -m ping
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://w3xse7en.github.io/k8s_local/20_install_k8s/#使用ansible对每台机器进行批处理&#34;&gt;更新新节点功能(时区,防火墙等)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;新增node4&#34;&gt;新增node4&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vi inventory/mycluster/hosts.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;all:
  hosts:
    node1:
      ansible_host: 192.168.1.200
      ip: 192.168.1.200
      access_ip: 192.168.1.200
    node2:
      ansible_host: 192.168.1.201
      ip: 192.168.1.201
      access_ip: 192.168.1.201
    node3:
      ansible_host: 192.168.1.202
      ip: 192.168.1.202
      access_ip: 192.168.1.202
    node4:
      ansible_host: 192.168.1.203
      ip: 192.168.1.203
      access_ip: 192.168.1.203
  children:
    kube-master:
      hosts:
        node1:
        node2:
    kube-node:
      hosts:
        node1:
        node2:
        node3:
        node4:
    etcd:
      hosts:
        node1:
        node2:
        node3:
    k8s-cluster:
      children:
        kube-master:
        kube-node:
    calico-rr:
      hosts: {}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;下载依赖&#34;&gt;下载依赖&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;假设&lt;code&gt;node1&lt;/code&gt;与&lt;code&gt;node4&lt;/code&gt;为同系统
将&lt;code&gt;node1&lt;/code&gt; &lt;code&gt;/tmp/releases&lt;/code&gt; &lt;code&gt;copy&lt;/code&gt;至&lt;code&gt;node4&lt;/code&gt; &lt;code&gt;/tmp/releases&lt;/code&gt;即可避免&lt;code&gt;node4&lt;/code&gt;再次下载k8s依赖组件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;scp /tmp/releases root@192.168.1.203:/tmp/releases
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;确定依赖已完善&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ansible-playbook -i inventory/mycluster/hosts.yaml  --become --become-user=root cluster.yml --tags container_engine

ansible-playbook -i inventory/mycluster/hosts.yaml  --become --become-user=root cluster.yml --tags download
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;添加节点-1&#34;&gt;添加节点&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ansible-playbook -i inventory/mycluster/hosts.yaml scale.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
&lt;hr&gt;
&lt;h2 id=&#34;移除节点&#34;&gt;移除节点&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ansible-playbook -i inventory/mycluster/hosts.yaml remove-node.yml --extra-vars &amp;quot;node=node4&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>创建 service account</title>
      <link>https://w3xse7en.github.io/k8s_local/40_service_account/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://w3xse7en.github.io/k8s_local/40_service_account/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.auroria.io/kubernetes-ci-cd-service-account-setup/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Setting up a Kubernetes CI/CD Service Account&lt;/a&gt;&lt;/p&gt;
&lt;br/&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;场景&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;权限划分，&lt;code&gt;cicd&lt;/code&gt;限定&lt;code&gt;namespace=dev&lt;/code&gt;使用&lt;code&gt;kubectl apply -f&lt;/code&gt;部署服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建 &lt;code&gt;namespace&lt;/code&gt; &lt;code&gt;dev&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat &amp;lt;&amp;lt;EOF | kubectl apply -f -
{
  &amp;quot;apiVersion&amp;quot;: &amp;quot;v1&amp;quot;,
  &amp;quot;kind&amp;quot;: &amp;quot;Namespace&amp;quot;,
  &amp;quot;metadata&amp;quot;: {
    &amp;quot;name&amp;quot;: &amp;quot;dev&amp;quot;,
    &amp;quot;labels&amp;quot;: {
      &amp;quot;name&amp;quot;: &amp;quot;dev&amp;quot;
    }
  }
}
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;创建-service-account-cicd-user&#34;&gt;创建 &lt;code&gt;service account&lt;/code&gt; &lt;code&gt;cicd-user&lt;/code&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 该脚本依赖 jq 组件
yum install jq -y

# [可修改]
SERVICE_ACCOUNT_NAME=&amp;quot;cicd-user&amp;quot;

# [可修改]
NAMESPACE=&amp;quot;dev&amp;quot;

# [可修改]
TARGET_FOLDER=&amp;quot;/home/k8s/kube&amp;quot;

kubectl create sa &amp;quot;${SERVICE_ACCOUNT_NAME}&amp;quot; --namespace &amp;quot;${NAMESPACE}&amp;quot;

mkdir -p &amp;quot;${TARGET_FOLDER}&amp;quot;

SECRET_NAME=$(kubectl get sa &amp;quot;${SERVICE_ACCOUNT_NAME}&amp;quot; --namespace=&amp;quot;${NAMESPACE}&amp;quot; -o json | jq -r .secrets[].name)

kubectl get secret --namespace &amp;quot;${NAMESPACE}&amp;quot; &amp;quot;${SECRET_NAME}&amp;quot; -o json | jq -r &#39;.data[&amp;quot;ca.crt&amp;quot;]&#39; | base64 --decode &amp;gt; &amp;quot;${TARGET_FOLDER}/ca.crt&amp;quot;

USER_TOKEN=$(kubectl get secret --namespace &amp;quot;${NAMESPACE}&amp;quot; &amp;quot;${SECRET_NAME}&amp;quot; -o json | jq -r &#39;.data[&amp;quot;token&amp;quot;]&#39; | base64 --decode)

KUBECFG_FILE_NAME=&amp;quot;${TARGET_FOLDER}/k8s-${SERVICE_ACCOUNT_NAME}-${NAMESPACE}-conf&amp;quot;

context=$(kubectl config current-context)

CLUSTER_NAME=$(kubectl config get-contexts &amp;quot;$context&amp;quot; | awk &#39;{print $3}&#39; | tail -n 1)

ENDPOINT=$(kubectl config view \
-o jsonpath=&amp;quot;{.clusters[?(@.name == \&amp;quot;${CLUSTER_NAME}\&amp;quot;)].cluster.server}&amp;quot;)

kubectl config set-cluster &amp;quot;${CLUSTER_NAME}&amp;quot; \
--kubeconfig=&amp;quot;${KUBECFG_FILE_NAME}&amp;quot; \
--server=&amp;quot;${ENDPOINT}&amp;quot; \
--certificate-authority=&amp;quot;${TARGET_FOLDER}/ca.crt&amp;quot; \
--embed-certs=true

kubectl config set-credentials \
&amp;quot;${SERVICE_ACCOUNT_NAME}-${NAMESPACE}-${CLUSTER_NAME}&amp;quot; \
--kubeconfig=&amp;quot;${KUBECFG_FILE_NAME}&amp;quot; \
--token=&amp;quot;${USER_TOKEN}&amp;quot;


kubectl config set-context \
&amp;quot;${SERVICE_ACCOUNT_NAME}-${NAMESPACE}-${CLUSTER_NAME}&amp;quot; \
--kubeconfig=&amp;quot;${KUBECFG_FILE_NAME}&amp;quot; \
--cluster=&amp;quot;${CLUSTER_NAME}&amp;quot; \
--user=&amp;quot;${SERVICE_ACCOUNT_NAME}-${NAMESPACE}-${CLUSTER_NAME}&amp;quot; \
--namespace=&amp;quot;${NAMESPACE}&amp;quot;

kubectl config use-context &amp;quot;${SERVICE_ACCOUNT_NAME}-${NAMESPACE}-${CLUSTER_NAME}&amp;quot; \
--kubeconfig=&amp;quot;${KUBECFG_FILE_NAME}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;为-cicd-user-配置权限&#34;&gt;为 &lt;code&gt;cicd-user&lt;/code&gt; 配置权限&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat &amp;lt;&amp;lt;EOF | kubectl apply -f -
kind: Role
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: &amp;quot;${SERVICE_ACCOUNT_NAME}-role&amp;quot;
  namespace: &amp;quot;${NAMESPACE}&amp;quot;
rules:
- apiGroups:
  - &amp;quot;&amp;quot;
  - apps
  - extensions
  resources:
  - &#39;*&#39;
  verbs:
  - &#39;*&#39;
---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: &amp;quot;${SERVICE_ACCOUNT_NAME}-role&amp;quot;
  namespace: &amp;quot;${NAMESPACE}&amp;quot;
subjects:
  - kind: ServiceAccount
    name: &amp;quot;${SERVICE_ACCOUNT_NAME}&amp;quot;
roleRef:
  kind: Role
  name: &amp;quot;${SERVICE_ACCOUNT_NAME}-role&amp;quot;
  apiGroup: rbac.authorization.k8s.io
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;其他实例使用-cicd-user&#34;&gt;其他实例使用 &lt;code&gt;cicd-user&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将&lt;code&gt;${TARGET_FOLDER}&lt;/code&gt;生成的&lt;code&gt;k8s-cicd-user-dev-conf&lt;/code&gt;文件&lt;code&gt;copy&lt;/code&gt;至其他实例&lt;code&gt;~/.kube&lt;/code&gt;路径下改名为&lt;code&gt;config&lt;/code&gt;使用&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;注意查看&lt;code&gt;k8s-cicd-user-dev-conf&lt;/code&gt;里&lt;code&gt;cluster server&lt;/code&gt;地址是否合法&lt;/p&gt;
&lt;p&gt;遇到证书ip问题请查看&lt;a href=&#34;https://w3xse7en.github.io/k8s_local/999_qa/#kubectl-get-nodes-%E8%AF%81%E4%B9%A6ip%E9%97%AE%E9%A2%98&#34;&gt;kubectl get pods 证书ip问题&lt;/a&gt;&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;br/&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>solve k8s problem</title>
      <link>https://w3xse7en.github.io/k8s_local/999_qa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://w3xse7en.github.io/k8s_local/999_qa/</guid>
      <description>&lt;hr&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;记录在使用k8s过程中所遇到的问题，以及解决方案&lt;/p&gt;
&lt;br/&gt;
&lt;hr&gt;
&lt;h2 id=&#34;kubectl-get-nodes-证书ip问题&#34;&gt;kubectl get nodes 证书ip问题&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Unable to connect to the server: x509: certificate is valid for 10.233.0.1, 172.19.157.57, 172.19.157.57, 10.233.0.1, 127.0.0.1, 172.19.157.57, 172.19.252.199, not 47.xxx.xx.x
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;场景&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;阿里云安装，全部使用私网地址，创建&lt;code&gt;service account&lt;/code&gt;后使用&lt;code&gt;kubectl&lt;/code&gt;从公网访问报错&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决方案
&lt;code&gt;supplementary_addresses_in_ssl_keys&lt;/code&gt; 添加公网地址&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vi inventory/mycluster/group_vars/k8s-cluster/k8s-cluster.yml

supplementary_addresses_in_ssl_keys: [47.xxx.xx.x]

# 重新安装部署，使配置生效
ansible-playbook -i inventory/mycluster/hosts.yaml  --become --become-user=root cluster.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;参考&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/a/55065519&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Invalid x509 certificate for kubernetes master&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;经验证&lt;code&gt;kubespray v2.14.1&lt;/code&gt;不需要执行&lt;code&gt;rm /etc/kubernetes/pki/apiserver.*&lt;/code&gt;&lt;/p&gt;
&lt;br/&gt;
&lt;hr&gt;
&lt;h2 id=&#34;systemanonymous-无法访问-k8s-dashboard&#34;&gt;system:anonymous 无法访问 k8s dashboard&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;`services &amp;quot;https:kubernetes-dashboard:&amp;quot; is forbidden: User &amp;quot;system:anonymous&amp;quot; cannot get services/proxy in the namespace &amp;quot;kube-system&amp;quot;`
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;解决方案
添加&lt;code&gt;system:anonymous&lt;/code&gt;的访问权限&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat &amp;lt;&amp;lt;EOF | kubectl apply -f -
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: kubernetes-dashboard-anonymous
rules:
- apiGroups: [&amp;quot;&amp;quot;]
  resources: [&amp;quot;services/proxy&amp;quot;]
  resourceNames: [&amp;quot;https:kubernetes-dashboard:&amp;quot;]
  verbs: [&amp;quot;get&amp;quot;, &amp;quot;list&amp;quot;, &amp;quot;watch&amp;quot;, &amp;quot;create&amp;quot;, &amp;quot;update&amp;quot;, &amp;quot;patch&amp;quot;, &amp;quot;delete&amp;quot;]
- nonResourceURLs: [&amp;quot;/ui&amp;quot;, &amp;quot;/ui/*&amp;quot;, &amp;quot;/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/*&amp;quot;]
  verbs: [&amp;quot;get&amp;quot;, &amp;quot;list&amp;quot;, &amp;quot;watch&amp;quot;, &amp;quot;create&amp;quot;, &amp;quot;update&amp;quot;, &amp;quot;patch&amp;quot;, &amp;quot;delete&amp;quot;]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: kubernetes-dashboard-anonymous
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: kubernetes-dashboard-anonymous
subjects:
- kind: User
  name: system:anonymous
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;参考&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/a/57830002&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Enable Access for Kubernetes Dashboard via external VIP or Floating IP&lt;/a&gt;&lt;/p&gt;
&lt;br/&gt;
&lt;hr&gt;
</description>
    </item>
    
  </channel>
</rss>
